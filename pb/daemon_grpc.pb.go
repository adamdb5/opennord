// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DaemonClient is the client API for Daemon service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DaemonClient interface {
	AccountInfo(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountResponse, error)
	Cities(ctx context.Context, in *CitiesRequest, opts ...grpc.CallOption) (*CitiesResponse, error)
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*Payload, error)
	Countries(ctx context.Context, in *CountriesRequest, opts ...grpc.CallOption) (*CountriesResponse, error)
	Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*Payload, error)
	FrontendCountries(ctx context.Context, in *CountriesRequest, opts ...grpc.CallOption) (*FrontendCountriesResponse, error)
	Groups(ctx context.Context, in *GroupsRequest, opts ...grpc.CallOption) (*GroupsResponse, error)
	IsLoggedIn(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IsLoggedInResponse, error)
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error)
	LoginOAuth2(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error)
	LoginOAuth2Callback(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error)
	Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*Payload, error)
	Plans(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PlansResponse, error)
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	RateConnection(ctx context.Context, in *RateRequest, opts ...grpc.CallOption) (*Payload, error)
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*Payload, error)
	SetAutoConnect(ctx context.Context, in *SetAutoConnectRequest, opts ...grpc.CallOption) (*Payload, error)
	SetCyberSec(ctx context.Context, in *SetCyberSecRequest, opts ...grpc.CallOption) (*Payload, error)
	SetDefaults(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error)
	SetDns(ctx context.Context, in *SetDNSRequest, opts ...grpc.CallOption) (*Payload, error)
	SetFirewall(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetKillSwitch(ctx context.Context, in *SetKillSwitchRequest, opts ...grpc.CallOption) (*Payload, error)
	SetNotify(ctx context.Context, in *SetNotifyRequest, opts ...grpc.CallOption) (*Payload, error)
	SetObfuscate(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
	SetProtocol(ctx context.Context, in *SetProtocolRequest, opts ...grpc.CallOption) (*Payload, error)
	SetTechnology(ctx context.Context, in *SetTechnologyRequest, opts ...grpc.CallOption) (*Payload, error)
	SetWhitelist(ctx context.Context, in *SetWhitelistRequest, opts ...grpc.CallOption) (*Payload, error)
	Settings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*SettingsResponse, error)
	SettingsProtocols(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*Payload, error)
	SettingsTechnologies(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*Payload, error)
	Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusResponse, error)
	SetIpv6(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error)
}

type daemonClient struct {
	cc grpc.ClientConnInterface
}

func NewDaemonClient(cc grpc.ClientConnInterface) DaemonClient {
	return &daemonClient{cc}
}

func (c *daemonClient) AccountInfo(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountResponse, error) {
	out := new(AccountResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/AccountInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Cities(ctx context.Context, in *CitiesRequest, opts ...grpc.CallOption) (*CitiesResponse, error) {
	out := new(CitiesResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Cities", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Connect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Countries(ctx context.Context, in *CountriesRequest, opts ...grpc.CallOption) (*CountriesResponse, error) {
	out := new(CountriesResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Countries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Disconnect(ctx context.Context, in *DisconnectRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Disconnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) FrontendCountries(ctx context.Context, in *CountriesRequest, opts ...grpc.CallOption) (*FrontendCountriesResponse, error) {
	out := new(FrontendCountriesResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/FrontendCountries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Groups(ctx context.Context, in *GroupsRequest, opts ...grpc.CallOption) (*GroupsResponse, error) {
	out := new(GroupsResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Groups", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) IsLoggedIn(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*IsLoggedInResponse, error) {
	out := new(IsLoggedInResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/IsLoggedIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResponse, error) {
	out := new(LoginResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) LoginOAuth2(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/LoginOAuth2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) LoginOAuth2Callback(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/LoginOAuth2Callback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Logout(ctx context.Context, in *LogoutRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Plans(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PlansResponse, error) {
	out := new(PlansResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Plans", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) RateConnection(ctx context.Context, in *RateRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/RateConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetAutoConnect(ctx context.Context, in *SetAutoConnectRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetAutoConnect", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetCyberSec(ctx context.Context, in *SetCyberSecRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetCyberSec", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetDefaults(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetDefaults", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetDns(ctx context.Context, in *SetDNSRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetDns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetFirewall(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetFirewall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetKillSwitch(ctx context.Context, in *SetKillSwitchRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetKillSwitch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetNotify(ctx context.Context, in *SetNotifyRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetNotify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetObfuscate(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetObfuscate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetProtocol(ctx context.Context, in *SetProtocolRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetProtocol", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetTechnology(ctx context.Context, in *SetTechnologyRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetTechnology", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetWhitelist(ctx context.Context, in *SetWhitelistRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetWhitelist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Settings(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*SettingsResponse, error) {
	out := new(SettingsResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Settings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SettingsProtocols(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SettingsProtocols", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SettingsTechnologies(ctx context.Context, in *SettingsRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SettingsTechnologies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) Status(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/pb.Daemon/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonClient) SetIpv6(ctx context.Context, in *SetGenericRequest, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.Daemon/SetIpv6", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonServer is the server API for Daemon service.
// All implementations must embed UnimplementedDaemonServer
// for forward compatibility
type DaemonServer interface {
	AccountInfo(context.Context, *AccountRequest) (*AccountResponse, error)
	Cities(context.Context, *CitiesRequest) (*CitiesResponse, error)
	Connect(context.Context, *ConnectRequest) (*Payload, error)
	Countries(context.Context, *CountriesRequest) (*CountriesResponse, error)
	Disconnect(context.Context, *DisconnectRequest) (*Payload, error)
	FrontendCountries(context.Context, *CountriesRequest) (*FrontendCountriesResponse, error)
	Groups(context.Context, *GroupsRequest) (*GroupsResponse, error)
	IsLoggedIn(context.Context, *emptypb.Empty) (*IsLoggedInResponse, error)
	Login(context.Context, *LoginRequest) (*LoginResponse, error)
	LoginOAuth2(context.Context, *emptypb.Empty) (*Payload, error)
	LoginOAuth2Callback(context.Context, *emptypb.Empty) (*Payload, error)
	Logout(context.Context, *LogoutRequest) (*Payload, error)
	Plans(context.Context, *emptypb.Empty) (*PlansResponse, error)
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	RateConnection(context.Context, *RateRequest) (*Payload, error)
	Register(context.Context, *RegisterRequest) (*Payload, error)
	SetAutoConnect(context.Context, *SetAutoConnectRequest) (*Payload, error)
	SetCyberSec(context.Context, *SetCyberSecRequest) (*Payload, error)
	SetDefaults(context.Context, *emptypb.Empty) (*Payload, error)
	SetDns(context.Context, *SetDNSRequest) (*Payload, error)
	SetFirewall(context.Context, *SetGenericRequest) (*Payload, error)
	SetKillSwitch(context.Context, *SetKillSwitchRequest) (*Payload, error)
	SetNotify(context.Context, *SetNotifyRequest) (*Payload, error)
	SetObfuscate(context.Context, *SetGenericRequest) (*Payload, error)
	SetProtocol(context.Context, *SetProtocolRequest) (*Payload, error)
	SetTechnology(context.Context, *SetTechnologyRequest) (*Payload, error)
	SetWhitelist(context.Context, *SetWhitelistRequest) (*Payload, error)
	Settings(context.Context, *SettingsRequest) (*SettingsResponse, error)
	SettingsProtocols(context.Context, *SettingsRequest) (*Payload, error)
	SettingsTechnologies(context.Context, *SettingsRequest) (*Payload, error)
	Status(context.Context, *emptypb.Empty) (*StatusResponse, error)
	SetIpv6(context.Context, *SetGenericRequest) (*Payload, error)
	mustEmbedUnimplementedDaemonServer()
}

// UnimplementedDaemonServer must be embedded to have forward compatible implementations.
type UnimplementedDaemonServer struct {
}

func (UnimplementedDaemonServer) AccountInfo(context.Context, *AccountRequest) (*AccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AccountInfo not implemented")
}
func (UnimplementedDaemonServer) Cities(context.Context, *CitiesRequest) (*CitiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cities not implemented")
}
func (UnimplementedDaemonServer) Connect(context.Context, *ConnectRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedDaemonServer) Countries(context.Context, *CountriesRequest) (*CountriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Countries not implemented")
}
func (UnimplementedDaemonServer) Disconnect(context.Context, *DisconnectRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Disconnect not implemented")
}
func (UnimplementedDaemonServer) FrontendCountries(context.Context, *CountriesRequest) (*FrontendCountriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FrontendCountries not implemented")
}
func (UnimplementedDaemonServer) Groups(context.Context, *GroupsRequest) (*GroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Groups not implemented")
}
func (UnimplementedDaemonServer) IsLoggedIn(context.Context, *emptypb.Empty) (*IsLoggedInResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsLoggedIn not implemented")
}
func (UnimplementedDaemonServer) Login(context.Context, *LoginRequest) (*LoginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedDaemonServer) LoginOAuth2(context.Context, *emptypb.Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginOAuth2 not implemented")
}
func (UnimplementedDaemonServer) LoginOAuth2Callback(context.Context, *emptypb.Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginOAuth2Callback not implemented")
}
func (UnimplementedDaemonServer) Logout(context.Context, *LogoutRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (UnimplementedDaemonServer) Plans(context.Context, *emptypb.Empty) (*PlansResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Plans not implemented")
}
func (UnimplementedDaemonServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedDaemonServer) RateConnection(context.Context, *RateRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RateConnection not implemented")
}
func (UnimplementedDaemonServer) Register(context.Context, *RegisterRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedDaemonServer) SetAutoConnect(context.Context, *SetAutoConnectRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAutoConnect not implemented")
}
func (UnimplementedDaemonServer) SetCyberSec(context.Context, *SetCyberSecRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCyberSec not implemented")
}
func (UnimplementedDaemonServer) SetDefaults(context.Context, *emptypb.Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaults not implemented")
}
func (UnimplementedDaemonServer) SetDns(context.Context, *SetDNSRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDns not implemented")
}
func (UnimplementedDaemonServer) SetFirewall(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetFirewall not implemented")
}
func (UnimplementedDaemonServer) SetKillSwitch(context.Context, *SetKillSwitchRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetKillSwitch not implemented")
}
func (UnimplementedDaemonServer) SetNotify(context.Context, *SetNotifyRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNotify not implemented")
}
func (UnimplementedDaemonServer) SetObfuscate(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetObfuscate not implemented")
}
func (UnimplementedDaemonServer) SetProtocol(context.Context, *SetProtocolRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProtocol not implemented")
}
func (UnimplementedDaemonServer) SetTechnology(context.Context, *SetTechnologyRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTechnology not implemented")
}
func (UnimplementedDaemonServer) SetWhitelist(context.Context, *SetWhitelistRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetWhitelist not implemented")
}
func (UnimplementedDaemonServer) Settings(context.Context, *SettingsRequest) (*SettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Settings not implemented")
}
func (UnimplementedDaemonServer) SettingsProtocols(context.Context, *SettingsRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettingsProtocols not implemented")
}
func (UnimplementedDaemonServer) SettingsTechnologies(context.Context, *SettingsRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettingsTechnologies not implemented")
}
func (UnimplementedDaemonServer) Status(context.Context, *emptypb.Empty) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedDaemonServer) SetIpv6(context.Context, *SetGenericRequest) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIpv6 not implemented")
}
func (UnimplementedDaemonServer) mustEmbedUnimplementedDaemonServer() {}

// UnsafeDaemonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DaemonServer will
// result in compilation errors.
type UnsafeDaemonServer interface {
	mustEmbedUnimplementedDaemonServer()
}

func RegisterDaemonServer(s grpc.ServiceRegistrar, srv DaemonServer) {
	s.RegisterService(&Daemon_ServiceDesc, srv)
}

func _Daemon_AccountInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).AccountInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/AccountInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).AccountInfo(ctx, req.(*AccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Cities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Cities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Cities",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Cities(ctx, req.(*CitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Countries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Countries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Countries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Countries(ctx, req.(*CountriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Disconnect(ctx, req.(*DisconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_FrontendCountries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).FrontendCountries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/FrontendCountries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).FrontendCountries(ctx, req.(*CountriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Groups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Groups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Groups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Groups(ctx, req.(*GroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_IsLoggedIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).IsLoggedIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/IsLoggedIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).IsLoggedIn(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_LoginOAuth2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).LoginOAuth2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/LoginOAuth2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).LoginOAuth2(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_LoginOAuth2Callback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).LoginOAuth2Callback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/LoginOAuth2Callback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).LoginOAuth2Callback(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Logout(ctx, req.(*LogoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Plans_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Plans(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Plans",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Plans(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_RateConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).RateConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/RateConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).RateConnection(ctx, req.(*RateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetAutoConnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAutoConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetAutoConnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetAutoConnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetAutoConnect(ctx, req.(*SetAutoConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetCyberSec_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCyberSecRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetCyberSec(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetCyberSec",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetCyberSec(ctx, req.(*SetCyberSecRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetDefaults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetDefaults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetDefaults",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetDefaults(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetDns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDNSRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetDns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetDns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetDns(ctx, req.(*SetDNSRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetFirewall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetFirewall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetFirewall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetFirewall(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetKillSwitch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetKillSwitchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetKillSwitch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetKillSwitch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetKillSwitch(ctx, req.(*SetKillSwitchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetNotify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNotifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetNotify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetNotify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetNotify(ctx, req.(*SetNotifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetObfuscate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetObfuscate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetObfuscate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetObfuscate(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetProtocol_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProtocolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetProtocol(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetProtocol",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetProtocol(ctx, req.(*SetProtocolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetTechnology_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTechnologyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetTechnology(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetTechnology",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetTechnology(ctx, req.(*SetTechnologyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetWhitelist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetWhitelistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetWhitelist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetWhitelist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetWhitelist(ctx, req.(*SetWhitelistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Settings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Settings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Settings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Settings(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SettingsProtocols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SettingsProtocols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SettingsProtocols",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SettingsProtocols(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SettingsTechnologies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SettingsTechnologies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SettingsTechnologies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SettingsTechnologies(ctx, req.(*SettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).Status(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Daemon_SetIpv6_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGenericRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServer).SetIpv6(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Daemon/SetIpv6",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServer).SetIpv6(ctx, req.(*SetGenericRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Daemon_ServiceDesc is the grpc.ServiceDesc for Daemon service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Daemon_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Daemon",
	HandlerType: (*DaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AccountInfo",
			Handler:    _Daemon_AccountInfo_Handler,
		},
		{
			MethodName: "Cities",
			Handler:    _Daemon_Cities_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _Daemon_Connect_Handler,
		},
		{
			MethodName: "Countries",
			Handler:    _Daemon_Countries_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _Daemon_Disconnect_Handler,
		},
		{
			MethodName: "FrontendCountries",
			Handler:    _Daemon_FrontendCountries_Handler,
		},
		{
			MethodName: "Groups",
			Handler:    _Daemon_Groups_Handler,
		},
		{
			MethodName: "IsLoggedIn",
			Handler:    _Daemon_IsLoggedIn_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Daemon_Login_Handler,
		},
		{
			MethodName: "LoginOAuth2",
			Handler:    _Daemon_LoginOAuth2_Handler,
		},
		{
			MethodName: "LoginOAuth2Callback",
			Handler:    _Daemon_LoginOAuth2Callback_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _Daemon_Logout_Handler,
		},
		{
			MethodName: "Plans",
			Handler:    _Daemon_Plans_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Daemon_Ping_Handler,
		},
		{
			MethodName: "RateConnection",
			Handler:    _Daemon_RateConnection_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _Daemon_Register_Handler,
		},
		{
			MethodName: "SetAutoConnect",
			Handler:    _Daemon_SetAutoConnect_Handler,
		},
		{
			MethodName: "SetCyberSec",
			Handler:    _Daemon_SetCyberSec_Handler,
		},
		{
			MethodName: "SetDefaults",
			Handler:    _Daemon_SetDefaults_Handler,
		},
		{
			MethodName: "SetDns",
			Handler:    _Daemon_SetDns_Handler,
		},
		{
			MethodName: "SetFirewall",
			Handler:    _Daemon_SetFirewall_Handler,
		},
		{
			MethodName: "SetKillSwitch",
			Handler:    _Daemon_SetKillSwitch_Handler,
		},
		{
			MethodName: "SetNotify",
			Handler:    _Daemon_SetNotify_Handler,
		},
		{
			MethodName: "SetObfuscate",
			Handler:    _Daemon_SetObfuscate_Handler,
		},
		{
			MethodName: "SetProtocol",
			Handler:    _Daemon_SetProtocol_Handler,
		},
		{
			MethodName: "SetTechnology",
			Handler:    _Daemon_SetTechnology_Handler,
		},
		{
			MethodName: "SetWhitelist",
			Handler:    _Daemon_SetWhitelist_Handler,
		},
		{
			MethodName: "Settings",
			Handler:    _Daemon_Settings_Handler,
		},
		{
			MethodName: "SettingsProtocols",
			Handler:    _Daemon_SettingsProtocols_Handler,
		},
		{
			MethodName: "SettingsTechnologies",
			Handler:    _Daemon_SettingsTechnologies_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _Daemon_Status_Handler,
		},
		{
			MethodName: "SetIpv6",
			Handler:    _Daemon_SetIpv6_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/daemon.proto",
}

// DaemonConnectClient is the client API for DaemonConnect service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DaemonConnectClient interface {
	Recv(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error)
}

type daemonConnectClient struct {
	cc grpc.ClientConnInterface
}

func NewDaemonConnectClient(cc grpc.ClientConnInterface) DaemonConnectClient {
	return &daemonConnectClient{cc}
}

func (c *daemonConnectClient) Recv(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.DaemonConnect/Recv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonConnectServer is the server API for DaemonConnect service.
// All implementations must embed UnimplementedDaemonConnectServer
// for forward compatibility
type DaemonConnectServer interface {
	Recv(context.Context, *emptypb.Empty) (*Payload, error)
	mustEmbedUnimplementedDaemonConnectServer()
}

// UnimplementedDaemonConnectServer must be embedded to have forward compatible implementations.
type UnimplementedDaemonConnectServer struct {
}

func (UnimplementedDaemonConnectServer) Recv(context.Context, *emptypb.Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Recv not implemented")
}
func (UnimplementedDaemonConnectServer) mustEmbedUnimplementedDaemonConnectServer() {}

// UnsafeDaemonConnectServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DaemonConnectServer will
// result in compilation errors.
type UnsafeDaemonConnectServer interface {
	mustEmbedUnimplementedDaemonConnectServer()
}

func RegisterDaemonConnectServer(s grpc.ServiceRegistrar, srv DaemonConnectServer) {
	s.RegisterService(&DaemonConnect_ServiceDesc, srv)
}

func _DaemonConnect_Recv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonConnectServer).Recv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.DaemonConnect/Recv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonConnectServer).Recv(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// DaemonConnect_ServiceDesc is the grpc.ServiceDesc for DaemonConnect service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DaemonConnect_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.DaemonConnect",
	HandlerType: (*DaemonConnectServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Recv",
			Handler:    _DaemonConnect_Recv_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/daemon.proto",
}

// DaemonDisconnectClient is the client API for DaemonDisconnect service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DaemonDisconnectClient interface {
	Recv(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error)
}

type daemonDisconnectClient struct {
	cc grpc.ClientConnInterface
}

func NewDaemonDisconnectClient(cc grpc.ClientConnInterface) DaemonDisconnectClient {
	return &daemonDisconnectClient{cc}
}

func (c *daemonDisconnectClient) Recv(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.DaemonDisconnect/Recv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonDisconnectServer is the server API for DaemonDisconnect service.
// All implementations must embed UnimplementedDaemonDisconnectServer
// for forward compatibility
type DaemonDisconnectServer interface {
	Recv(context.Context, *emptypb.Empty) (*Payload, error)
	mustEmbedUnimplementedDaemonDisconnectServer()
}

// UnimplementedDaemonDisconnectServer must be embedded to have forward compatible implementations.
type UnimplementedDaemonDisconnectServer struct {
}

func (UnimplementedDaemonDisconnectServer) Recv(context.Context, *emptypb.Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Recv not implemented")
}
func (UnimplementedDaemonDisconnectServer) mustEmbedUnimplementedDaemonDisconnectServer() {}

// UnsafeDaemonDisconnectServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DaemonDisconnectServer will
// result in compilation errors.
type UnsafeDaemonDisconnectServer interface {
	mustEmbedUnimplementedDaemonDisconnectServer()
}

func RegisterDaemonDisconnectServer(s grpc.ServiceRegistrar, srv DaemonDisconnectServer) {
	s.RegisterService(&DaemonDisconnect_ServiceDesc, srv)
}

func _DaemonDisconnect_Recv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonDisconnectServer).Recv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.DaemonDisconnect/Recv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonDisconnectServer).Recv(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// DaemonDisconnect_ServiceDesc is the grpc.ServiceDesc for DaemonDisconnect service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DaemonDisconnect_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.DaemonDisconnect",
	HandlerType: (*DaemonDisconnectServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Recv",
			Handler:    _DaemonDisconnect_Recv_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/daemon.proto",
}

// DaemonOAuth2CallbackClient is the client API for DaemonOAuth2Callback service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DaemonOAuth2CallbackClient interface {
	Recv(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error)
}

type daemonOAuth2CallbackClient struct {
	cc grpc.ClientConnInterface
}

func NewDaemonOAuth2CallbackClient(cc grpc.ClientConnInterface) DaemonOAuth2CallbackClient {
	return &daemonOAuth2CallbackClient{cc}
}

func (c *daemonOAuth2CallbackClient) Recv(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Payload, error) {
	out := new(Payload)
	err := c.cc.Invoke(ctx, "/pb.DaemonOAuth2Callback/Recv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonOAuth2CallbackServer is the server API for DaemonOAuth2Callback service.
// All implementations must embed UnimplementedDaemonOAuth2CallbackServer
// for forward compatibility
type DaemonOAuth2CallbackServer interface {
	Recv(context.Context, *emptypb.Empty) (*Payload, error)
	mustEmbedUnimplementedDaemonOAuth2CallbackServer()
}

// UnimplementedDaemonOAuth2CallbackServer must be embedded to have forward compatible implementations.
type UnimplementedDaemonOAuth2CallbackServer struct {
}

func (UnimplementedDaemonOAuth2CallbackServer) Recv(context.Context, *emptypb.Empty) (*Payload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Recv not implemented")
}
func (UnimplementedDaemonOAuth2CallbackServer) mustEmbedUnimplementedDaemonOAuth2CallbackServer() {}

// UnsafeDaemonOAuth2CallbackServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DaemonOAuth2CallbackServer will
// result in compilation errors.
type UnsafeDaemonOAuth2CallbackServer interface {
	mustEmbedUnimplementedDaemonOAuth2CallbackServer()
}

func RegisterDaemonOAuth2CallbackServer(s grpc.ServiceRegistrar, srv DaemonOAuth2CallbackServer) {
	s.RegisterService(&DaemonOAuth2Callback_ServiceDesc, srv)
}

func _DaemonOAuth2Callback_Recv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonOAuth2CallbackServer).Recv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.DaemonOAuth2Callback/Recv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonOAuth2CallbackServer).Recv(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// DaemonOAuth2Callback_ServiceDesc is the grpc.ServiceDesc for DaemonOAuth2Callback service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DaemonOAuth2Callback_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.DaemonOAuth2Callback",
	HandlerType: (*DaemonOAuth2CallbackServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Recv",
			Handler:    _DaemonOAuth2Callback_Recv_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/daemon.proto",
}
